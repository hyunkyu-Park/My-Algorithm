에라토스테네스의 체 알고리즘은 여러 개의 수가 소수인지 아닌지를 판별할 때 사용하는 대표적인 알고리즘이다.  
에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용할 수 있다.  

에라토스테네스의 체 알고리즘은 다음과 같다
1. 2부터 N까지의 모든 자연수를 나열한다
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
3. 남은 수 중에서 i의 배수를 모두 제거한다(i는 제거하지 않는다).
4. 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.
-----------------------------------------------------------------------------------------------------------
n=1000  # 2부터 1,000까지의 모든 수에 대하여 소수 판별
array=[True for i in range(n+1)] # 처음엔 모든 수가 소수(True)인 것으로 초기화(0과 1은 제외)

# 에라토스테네스의 체 알고리즘
for i in range(2, int(n**0.5) + 1):
    if array[i] == True: # i가 소수인 경우(남은 수인 경우)
        # i를 제외한 모든 배수를 지우기
        j=2
        while i*j <= n:
            array[i*j] = False
            j += 1
# 모든 소수 출력
for i in range(2, n+1):
    if array[i]:
        print(i, end=' ')
-----------------------------------------------------------------------------------------------------------  


에라토스테네스의 체를 사용 하지 않았을 때 소수 판별 함수
def is_prime_number(x):
  # 2부터 (x-1)까지의 모든 수를 확인하며
  for i in range(2, x):
    # x가 해당 수로 나누어떨어진다면
    if x % i == 0:
        return False # 소수가 아님
    return True #소수임
  
 체를 사용하지 않았을 때 시간 복잡도는 O(X)이다. 예를 들어 1,000,000이라는 수가 소수인지 확인해야 할 때는 1,000,000을 2부터 999,999까지의 모든 수에 대하여 하나씩 나누어야 한다.
 따라서 이와 같은 알고리즘을 작성하면 몹시 비효율적이다.
 
 자연수의 약수가 가지는 특징을 파악한다면 더 빠르게 동작하는 알고리즘을 만들 수 있다.
 예를 들어 16이라는 수의 약수는 1, 2, 4, 8, 16이다.
 이 때 모든 약수에 대하여, 가운데 약수를 기준으로 하여 대칭적으로 2개씩 앞뒤로 묶어서 곱하면 16을 만들 수 있다
 1 * 16
 2 * 8
 4 * 4
 8 * 2
 16 * 1
 여기에서 알 수 있는 점은 가운데 약수를 기준으로 해서 각 등식이 대칭적인 형태를 보인다는 것이다. 
 그렇기 때문에 우리는 특정한 자연수 X가 소수인지 확인하기 위하여 바로 가운데 약수까지만 '나누어떨어지는지' 확인하면 된다. 위의 예시에서는 4까지만 확인하면 된다.
 즉, 2, 3, 4를 확인하여 나누어떨어지는지 확인한다. 다시 말해 제곱근까지만(가운데 약수까지만) 확인하면 된다는 점을 기억하자.
 
 따라서 다음과 같이 코드를 작성하면 시간 복잡도 O(X^1/2)에 소수를 판별할 수 있다.
 
def is_prime_number(x):
  # 2부터 x의 제곱근까지의 모든 수를 확인하며
  for i in range(2, int(x**0.5)+1):
    # x가 해당 수로 나누어떨어진다면
    if x % i == 0:
        return False # 소수가 아님
    return True #소수임
  
